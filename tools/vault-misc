#!/bin/bash

master_branch=vault
scripts_branch=scripts
root_version=3
root=

trap "exit 1" TERM
export TOP_PID=$$

function warn {
    echo "`basename $0`: Warning: ${@:1}" 1>&2;
}

function error {
    TOP_RC=$1
    echo "`basename $0`: Error: ${@:2}" 1>&2;
    kill -s TERM $TOP_PID
}

is_trace=false
if [ "x$VAULT_TRACE" != "x" ]; then
  is_trace=true
fi

function trace {
    if $is_trace; then
        echo "`basename $0`: ${@:1}" 1>&2;
    fi
}

if [ $# -eq 1 ]; then
    src=$1
else
    src=`dirname $0`
    src=`cd $src;pwd`
fi
trace "SCRIPTS DIR: $src"
export PATH=$src:$PATH

function ensure_param_count_op_exit_usage {
    [ $@ -ge 3 ] || error 22 "Call as Num#0 OP Num#1"
    if ! [ $1 $2 $3 ]; then
        local name=`basename $0`
        echo "Expecting param count: $1 $2 $3" 1>&2;
        echo "Params was: ${@:5}" 1>&2;
        echo "Usage: $name $4" 1>&2;
        exit $1
    fi
}

function ensure_param_count_exit_usage {
    ensure_param_count_op_exit_usage $1 -eq $2 ${@:3}
}

function tree_version_path {
    [ $@ ] || error 22 "Call with root"
    echo $1/.vault
}

function repo_version_path {
    [ $@ ] || error 22 "Call with root"
    echo $1/.git/vault.version
}

function units_path {
    [ $@ ] || error 22 "Call with root"
    echo $1/.units/
}

function init_root {
    if [ "x$root" == "x" ]; then
        root=$(git vault-root)
        if [ $? -ne 0 ]; then
            error $? "Not a vault?"
        fi
        if [ "x$root" == "x" ]; then
            error 54 "Root is empty"
        fi
    fi
    version_file=$(tree_version_path $root)
    test -f "$version_file" || error 44 "Not a vault tree $root?"

    tree_version=$(cat $version_file)
    if [ "x$tree_version" == "x" ]; then
        error 10 "Empty tree version for $root"
    fi
    trace "Tree version $tree_version"
}

function init_root_and_enter {
    init_root
    cd $root || error 2 "Can't enter $root"
    echo $root
}

function get_vid {
    init_root
    git config --file $root/.git/config vault.id
}

function get_current_branch {
    echo $(git rev-parse --abbrev-ref HEAD)
}

function vault_exec {
    init_root
    local fname=$1
    local log_file=$root/.vault/logs/$2
    test -x $fname || error 77 "File is not an exec: $fname"
    local cur_dir=$(pwd)
    trace "Exec: ls -al $fname"
    local out_file=$log_file-out.txt
    local err_file=$log_file-err.txt
    touch $out_file
    touch $err_file
    $fname 1>$out_file 2> $err_file || error $? "File execution is failed: $fname"
    if [ "$(pwd)" != "$cur_dir" ]; then
        error 54 "Executable changed cwd to $(pwd)"
    fi
}

function date_tag {
    echo $(date +%Y-%m/%d/%Z/%H-%M/%S.%N)
}

function unique_tag {
    echo $(uuidgen)
}

function units {
    find .units -type f -name '*.json' -exec basename {} '.json' \;
}

function split_git_uri {
    uri=$1
    trace "split $uri"
    # parsing is too dumb now, it should be stricter
    ssh_re='(ssh://)?((.*)@)?(.*[^\\]):([0-9]*)(.*)'
    if [[ "$uri" =~ $ssh_re ]]; then
        trace "Remote URI is ssh"
        user="${BASH_REMATCH[3]}"
        host="${BASH_REMATCH[4]}"
        port="${BASH_REMATCH[5]}"
        src_repo="${BASH_REMATCH[6]}"
        src_type=ssh
    elif [[ $uri =~ (file://)?(.*) ]]; then
        trace "Assume URI is the local path"
        path="${BASH_REMATCH[2]}"
        src_repo=$path
        src_type=local
    fi
    if [ "x$user" == "x" ]; then
        user=$(whoami)
    fi
}

vault_misc=1
function get_vault_lock_cmd {
    # wait for 30s
    echo "flock -w 30 -x $root/.vault.lock $@"
}
export -f get_vault_lock_cmd
