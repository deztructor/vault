#!/bin/bash

src=$(dirname $0)
src=$(cd $src;pwd)
util_file=
if [ "x$VAULT_LIB_DIR" != "x" ]; then
    util_file=$VAULT_LIB_DIR/git-vault-helpers-remote
else
    util_file=$src/git-vault-helpers-remote
fi
if ! [ -f $util_file ]; then
    echo "Set VAULT_LIB_DIR $src" >&2
    exit 1
fi
source $util_file $src

trace "Args: $# is $@"
alias=$1
url=$2
proto=vault

print_caps() {
    trace_if 2 "Caps $cmd"
    echo "push"
    echo "fetch"
    echo "refspec refs/heads/*:refs/$proto/$alias/branches/*"
    echo "option"
    echo
}

save_option() {
    trace_if 2  "GIT: Save option $@"
    echo "unsupported"
}

do_push() {
    trace_if 2 "GIT: Push $@"
    local refs=$2
    if [[ ${refs:0:1} == "+" ]]; then
        refs=${refs:1}
    fi
    local delim=$(expr index "$refs" ':')
    local from=${refs:0:$(expr delim-1)}
    local to=${refs:$delim}
    local obj=$(obj_id $to)
    local is_update_head=true

    if [ "x$from" == "x" ]; then
        warn "TODO: delete $to"
        is_update_head=false
    else
        local from_id=$(git rev-parse $from)
        trace_if 3  "$from ($from_id) -> $to"
        ([[ -d $url ]] || mkdir -p $url) || error 15 "Can't mkdir $url"
        if [[ $to =~ notes/.* ]]; then
            trace_if 3  "Pushing notes"
            is_update_head=false
            local notes=$(tmp_path notes)
            git notes list > $notes
            for n in $(cat $notes | cut -d ' ' -f1); do
                # TODO remove also notes
                push_object $n
            done
            mv $notes $(notes_list_path)
        elif [ "x$(remote_head_id)" == "x$from_id" ]; then
            trace_if 3  "Skip $from_id, already taken"
        else
            trace_if 3  "Processing $from_id"
            local src_list_prefix=$(save_graph $from)

            # objects
            local actual_objects=$src_list_prefix.objects
            local saved_objects=$(tmp_path objects.saved)
            write_saved_objects $saved_objects
            process_sorted_ranges $saved_objects $actual_objects \
                                  push_object rm_remote_object

            # blobs
            local actual_blobs=$src_list_prefix.blobs
            local saved_blobs=$(tmp_path blobs.saved)
            write_saved_blobs $saved_blobs
            process_sorted_ranges $saved_blobs $actual_blobs \
                                  push_vault_blob rm_remote_blob

            # tags
            local tags_file=$(tmp_path tags)
            for tag in $(git tag); do
                echo "$tag $(git rev-parse $tag)" >> $tags_file
            done
            mv $tags_file $(tags_list_path)

            # record saved objects
            rm -f $url/*.objects
            rm -f $url/*.blobs
            cp $src_list_prefix.blobs $url/
            cp $src_list_prefix.objects $url/
        fi
    fi
    if $is_update_head; then
        echo "$from_id $from" > $(head_path $obj)
    fi
    tar cf $url/metadata.tar .git/info/exclude .git/vault.version
    echo
}

tag_object() {
    git tag $1 $2 || warn "Can't tag $1 $2"
}

do_fetch() {
    trace_if 2 "GIT: Fetch $@"
    # TODO now it ignores params, just fetches everything
    local saved_objects=$(tmp_path objects.saved)
    write_saved_objects_filenames $saved_objects
    local obj=
    for obj in $(cat $saved_objects); do
        fetch_object $obj
    done

    [ -d .git/blobs ] || (trace_if 2 "Creating blobs dir"; mkdir .git/blobs)
    local saved_blobs=$(tmp_path blobs.saved)
    write_saved_blobs $saved_blobs
    local actual_blobs=$(tmp_path blobs.actual)
    write_actual_blobs $actual_blobs

    process_sorted_ranges $actual_blobs $saved_blobs \
                          fetch_vault_blob rm_vault_blob

    apply_remote_tags tag_object
    local metadata_file=$url/metadata.tar
    [ -f $metadata_file ] && (trace_if 2 "Extracting metadata"; tar xf $metadata_file)
    local notes_list=$(notes_list_path)
    if [ -f $notes_list ]; then
        for n in $(cat $notes_list | tr ' ' ':'); do
            local delim=$(expr index "$n" ':')
            local note=$(remote_object_path ${n:0:$(expr delim-1)} "blob")
            local commit=${n:$delim}
            if [ -f $note ]; then
                git notes add -f -F $note $commit
            else
                warn "Can't find note $note"
            fi
        done
    else
        warn "No notes"
    fi
    echo
}

list_for_push() {
    trace_if 2 "for push $@"
    list_refs $@
}

while read cmd; do
    trace "GIT CMD: $cmd"
    case $cmd in
        capabilities)
            print_caps
            #break
            ;;
        option*)
            save_option $cmd
            ;;
        list)
            list_refs
            ;;
        push*)
            do_push $cmd
            ;;
        fetch*)
            do_fetch $cmd
            ;;
        "list for-push")
            list_for_push $cmd
            ;;
        *)
            [[ "x$cmd" == "x" ]] && break
            trace "Cmd: $cmd"
            ;;
    esac
done
